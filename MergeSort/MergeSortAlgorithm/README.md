Объяснение 1):
Пусть массив индексируется с первого номера.
Есть массив, есть его первый индекс, и последний.
Под понятием "делим", подразумевается разбиение индексов.
Суть такова, делим массив сначала на две равные части, потом одну из половин делим 
пополам, и так до тех пор пока не получим условный "подмассив" из одного элемента.
Т.е. путь от начального массива до этого элемента представляет собой ветку, и алгоритм
создает такую ветку для каждого элемента.
На конце каждой ветки по одному элементу.
Далее, берется первый и второй элементы, сортируются, и создают уже ячейку, с двумя 
отсортированными значениями. Потом следующие два элемента(3-ий номер и 4-ый) 
сортируются и создают ячейку из двух элементов. На данном этапе мы уже имеем две ячейки 
по два отсортированных элемента, а все остальные элементы в ячейчках по одном элементу. 
Т.е. мы двигаемся последовательно. Так вот, теперь те две ячейки мы объедияем в ячейку и
сортируем, где в итоге будет 4 отсортированных элемента. И так мы двигаемся, пока не 
отсортируем одну половину элементов, в данном случае у нас всего массива из 8 элементов, 
и только потом приступаем к ветке с другой половиной элементов массива. 
Т.е. если в массиве 8 элементов, мы разбиваем все элементы на одиночные ячейки,
потом берутся 1 и 2 элементы, сортируются и перезаписываются в изначальный массив, 
создавая при этом ячейку из двух элементов, далее берутся 3 и 4 элементы, сортируются,
перезаписываются в массив, создают условную ячейку из двух элементов. Следующим шагом будет 
объединение этих двух ячеек, каждая из которых содержит по 2 элемента, объединяем,
сортируем, в итоге получаем 4 отсортированных первых элемента массива. 
Первая половина массива отсортирована, приступаем ко второй. Делаем все тоже самое. Теперь
у нас есть два условных подмассива по 4 отсортированных элемента, мы их объединяем, при этом
сортируя, и перезаписываем в изначальный массив. В результате получаем отсортированный 
массив, по принципу алгоритма с рекурсией.
 

Объяснение 2):
Делим массив до тех пор, пока не получим массивы с одним элементом, т.к.
такой массив априори отсортирован.
Делим делим, получаем такие индексы начала массива и среднего индексы, что они равны,
тогда мы не можем разбить массив пополам, и выходим из такой процедуры; следующий
вызов процедуры тоже не сможет осуществить деление, и вернется, т.к. индексы таковы,
что у нас два массива по одному элементу - с массивом мы ничего не делали, это всего
лишь благодаря индексам.
Далее, мы сортируем значения из этих двух "массивов" и перезаписываем стартовый массив,
т.е. мы достигли только что первых двух элементов массива и отсортировали их.
Таким же образом мы достигнем следующие два элемента массива, т.е. под индексом 3 и 4, 
отсортируем их. И мы уже будем иметь два отсортированных мини массива. Теперь, нужно
эти два мини массива тоже объединить и отсортировать; делаем это, и получаем уже 
4 отсортированных элемента. 
Т.к. в данном случае у нас всего 8 элементов, то мы должны повторить все тоже самое,
только со второй половиной чисел. Достигаем элементов с индексами 5 и 6, сортируем их,
достигаем элементов с индексами 7 и 8, сортируем их, объединяем эти два массива,
сортируя их, и получаем 4 отсортированных элемента слева и 4 отсортированных слева.
Далее сортируем эти мини массивы с 4-мя отсортированными элементам в один массив
из 8 элементов. 
При этом, мы каждый раз перезаписывали исходный массив, т.к. мы ничего не теряли, мы
всего лишь находили два элемента, сортировали их, записывали обратно в исходный массив,
потом снова, следующие два числа взяли, отсортировали, перезаписывали

P.S. реализация на языке С, поэтому если массив содержит 8 элементов, то нумерация
начинается с нуля, и первый подмассив будет содержать индексы 0,1,2,3, а второй 4,5,6,7.